# 面向对象构造与设计第三单元总结

本单元三次作业的内容为根据JML规格实现相应的接口，模拟社交网络的运行。重点为JML规格的学习和代码正确性的测试，其次也包括了一些与图相关的算法。每次作业都在上一次的基础上增加了部分功能。总体而言，相比与前两单元作业，难度较低，因此也有了更多的精力去进行代码正确性的测试。

## 关于JML

JML(Java Modeling Language) 是用于对 Java 程序进行规格化设计的一种表示语言，它为严格的程序设计提供了一套行之有效的方法。通过 JML 及其支持工具，不仅可以基于规格自动构造测试用例，而且可以整合相关工具以静态方式来检查代码实现对规格的满足情况。

JML主要有两种用法：

- 开展规格化设计。这样设计人员可以用逻辑严谨的规格而不是模糊的自然语言进行设计，进而交给代码实现人员。
- 针对已有的代码书写规格。这样可以提高代码的可维护性，对遗留代码的维护具有重要的意义。

在本单元的作业中，我们担任的角色是代码实现人员，通过阅读已经书写的规格来实现具体的代码。同时也在实验课中简单练习了JML规格的书写。

## 实现规格所采取的设计策略

- 首先，阅读类的规格，了解类所包含的属性和主要方法，理清类与类之间的关系。
- 其次，细读主要方法的规格，了解具体的操作，预先构思不同的实现，再结合不同实现的时间复杂度等因素确定类中属性的数据结构。
- 最后，再根据属性的数据结构选取相应的算法实现具体的方法规格。

以上是总体的设计策略，此外，在实现时也有一些小的技巧：

- 在理解方法具体功能的基础上，尽量保证每一段的规格都有相应的代码对应，但这并不意味着要一句一句地去“翻译”规格，而是确保一个有逻辑的层次，避免遗漏部分规格，也方便在程序出现错误时找到与代码对应的规格。

- 对于前置条件，用*if*语句写出，此外，也尽量避免使用*else*，更多地使用了*else if*，这样做的目的也是为了避免遗漏对于条件的判断。例如，在第二次作业的*addToGroup()*方法中，虽然一开始官方的规格遗漏了一个条件，但由于采用了else if的分支，使得在遗漏的条件下并没有执行任何代码，因此并没有受到影响。

  

## 基于JML规格来设计测试的方法和策略

通过理论课的学习和查阅相关的资料，主要了解接触了OpenJML、JMLUnitNG、JUnit和对拍等测试方法。

### OpenJML

OpenJML最基本的功能是对JML规格的完整性进行检查，包括类型检查、变量可见性与可写性的检查等。可利用命令行通过以下语句使用OpenJML对指定的类进行检查。

```
openjml [-check] options files
```

### JMLUnitNG

JMLUnitNG是用于带有JML规格的Java代码的自动化单元测试生成工具，主要是生成边界数据进行测试。

### JUnit

JUnit是一个Java语言的单元测试框架，并且IDEA集成了JUnit作为单元测试的工具，使用起来相比OpenJML和JMLUnitNG更加方便。因此，我在本单元作业中重点利用JUnit进行了单元测试，通过编写测试类，手动构造基本的样例进行基本功能的检查。通过JUnit单元测试，可以在一定程度上测试代码的正确性，但在实际使用过程中也有一些弊端，例如，手动构造的样例无法覆盖所有可能的情况，而且随着功能的增加，编写测试类的代码量也越来越大，由此可见，测试代码的正确性并非易事。

### 对拍

在之前的作业中，已经使用过对拍的方法进行测试，通过“自动生成数据 + 对不同实现方法的代码输出进行对比”的方法是一个高效而且相对省力的测试方法，对于本单元的作业也是如此。我在本单元中利用python编写了数据生成和自动对拍程序，其中，数据生成的策略分为两种，一种是随机生成所有的指令，另一种是先执行多个*ap*和*ar*指令，构造基本的关系网络，再随机生成其他指令。随机的策略更多地测试各种异常，而构造的策略则可以更多地测试与*Group*和*Message*相关的指令。除了自动生成，也通过编写程序生成了一些特殊的数据，例如针对*isCircle()*和*sendInderiectMessage()*等方法而生成的特殊数据。

<br>

在本单元的作业中，我采取的测试策略为综合JUnit单元测试和对拍两种方法，首先手动构造样例，利用JUnit对基本的功能进行测试，基本功能无误后基本就可以通过中测了。随后再邀请其他同学共同进行对拍，对拍时将源码打包jar包，也避免了直接发送源码。可能是由于本单元作业较为简单的缘故，三次作业在本地对拍以及官方的中强测中均未出现bug，但通过对拍找到了其他同学的bug，可见，综合JUnit和对拍的策略在实际中有一定的效果。

## 容器的选择和使用的经验

在本单元的作业中，简单地按照JML规格中使用数组并不是一个明智的选择，因为在多个方法中都涉及对容器的增、删、改、查等操作，考虑到每个*person*、*group*、*message*、*emoji*都有独一无二的id，因此较多地使用了*HashMap*，使用*HashMap*不仅可以使用*put()*、*remove()*、*containsKey()*等方法方便地实现增、删、改、查等操作，也有利于各种算法的实现。

除了*HashMap()*，在*Person*类中，由于*getReceivedMessages()*方法的返回值为*List\<Message\>*类型，因此对*messages*属性使用了*List*；在*NetWork*类中，由于*emojiId*不允许重复，因此对*emojiIdList*属性使用了*HashSet*，但由于对*emojiHeatList*属性使用了*HashMap*，完全可以不必单独定义*emojiIdList*，同时定义这两个属性仅是为了保持和JML规格，减小出错的可能。

此外，在第三次作业的*sendInderiectMessage()*方法中由于涉及到最短路径的求解，而未优化的Dijkstra算法复杂度过高，因此采用了堆优化的Dijkstra算法，堆的具体实现使用了*PriorityQueue*这一容器，用到了*poll()*（取出堆顶元素）、*add()*、*isEmpty()*等方法。

选择合适的容器不仅可以方便操作、降低时间复杂度，还可以减少增量开发过程中对代码的改动。在本单元的作业中，因为一开始就考虑到了增、删、改、查等操作以及相应的时间复杂度，所以从第一次作业开始就选择了*HashMap*等合适的容器，使得后两次作业中可以继续使用，无需重新修改，这也是我对本单元作业较为满意的一点。

## 性能问题分析

在本单元的作业中，对程序的性能也提出了一定的要求，即一些方法的时间复杂度不能过高，需要选择合适的算法。

因为在一开始就意识到了本单元的作业是基于图这一数据结构的，可能涉及与图相关的算法，所以，尽管第一次作业的数据量不大，用简单的遍历也可以通过，但还是有意识地去思考了容器的选择和时间复杂度更低的算法，在三次作业中保证所有方法复杂度均小于O(n^2)，因此都没有出现性能问题。

具体的设计如下：

- 第一次作业：使用*HashMap*，增、删、改、查复杂度O(1)；*isCircle()*方法和*queryBlockSum()*方法采用了压缩路径的并查集算法，维护了*HashMap<Id, fatherId> father*这一属性，使得复杂度由遍历的O(n^2)降为O(n)。

- 第二次作业：同样使用*HashMap*，增、删、改、查复杂度O(1)；*getValueSum()*方法维护了*valueSum*这一中间变量，*getAgeMean()*方法维护了*ageSum*这一中间变量，*getAgeVar()*方法化简了方差公式并维护了*ageSum2*这一中间变量，值得注意的是，中间变量*valueSum*除了在*Group*加入或删除*Person*时需要改变，也要考虑先加入*Group*再添加*Relation*的情况，通过维护中间变量可以直接O(1)回答。

- 第三次作业：同样使用*HashMap*，增、删、改、查复杂度O(1)；*sendInderiectMessage()*方法中涉及求解最短路径，传统的Dijkstra算法时间复杂度为O(n^2)，利用优先队列（堆实现）的Dijkstra算法可以使得时间复杂度降为O(nlogn)。


## 架构设计

### 整体架构

本次作业的整体架构基本与官方代码保持一致，并未有过多改动，重点放在了对JML规格的实现上。仅在第三次作业时为了方便记录路径增加了*Path*类，其余基本上是实现了官方代码的接口。

![image-20210528095534733](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210528095534733.png)



### 图模型构建与维护策略

图的模型也基本由JML规格确定，即*Person*作为节点，*Relation*作为边，*value*作为权重，并采用邻接链表的方式存储，*acquaintance*作为邻接链表。

对于联通块，采用了并查集算法，增加了*father*属性，用*HashMap*存储每个节点的父节点，增加边时对父节点进行合并。

对于最短路径，采用了优先队列的Dijkstra算法，增加了*Path*类，存储某节点到起始节点的路径权值，用*HashMap*存储已获得到某节点的最短路径，用*PriorityQueue*存储未访问的路径。

此外，在增加边时，也要考虑对*Group*中中间变量的维护。

## 体会与感受

个人认为，与前两个单元侧重架构的设计相比，本单元的重点移向了对于JML规格的学习和代码正确性的测试。通过本单元的学习，不仅认识了JML这种形式化描述语言，初步掌握了JML规格，了解并实际运用了测试代码正确性的一些方法，而且回顾了数据结构学习的一些算法，收获较大。













